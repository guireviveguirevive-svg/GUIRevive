import re
import functools
from datetime import datetime
import sys
import argparse
import os

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile('^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
                                  '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$')


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess
    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random
    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib
    return hashlib.md5(input_str.encode('utf-8')).hexdigest()

def generate_html_report(output_dir, replay_output_dir=None, out_dir=None):
    """
    Generate a dual-column HTML report comparing record and replay actions
    
    :param output_dir: Directory containing record data (original test output)
    :param replay_output_dir: Directory containing replay data (optional)
    :param out_dir: Output directory for the complete report (HTML + images). If None, saves in output_dir
    """
    import os
    import json
    import glob
    import shutil
    
    # Determine if this is a replay comparison
    print(f"output_dir: {output_dir}")
    print(f"replay_output_dir: {replay_output_dir}")
    print(f"out_dir: {out_dir}")
    is_replay_comparison = replay_output_dir is not None and os.path.exists(replay_output_dir)
    print(f"is_replay_comparison: {is_replay_comparison}")
    
    # Get event files
    if is_replay_comparison:
        record_events_dir = os.path.join(output_dir, "events")
        replay_events_dir = os.path.join(replay_output_dir, "events")
        
        record_event_files = sorted(glob.glob(os.path.join(record_events_dir, "event_*.json")))
        replay_event_files = sorted(glob.glob(os.path.join(replay_events_dir, "event_*.json")))
        
        # Get states directories
        record_states_dir = os.path.join(output_dir, "states")
        replay_states_dir = os.path.join(replay_output_dir, "states")
    else:
        record_events_dir = os.path.join(output_dir, "events")
        record_event_files = sorted(glob.glob(os.path.join(record_events_dir, "event_*.json")))
        record_states_dir = os.path.join(output_dir, "states")
        replay_event_files = []
        replay_states_dir = None
    
    # Load events with numeric indices from filenames (event_<idx>.json)
    def _load_indexed_events(event_paths):
        events_by_idx = {}
        for event_file in event_paths:
            try:
                base = os.path.basename(event_file)
                name, _ = os.path.splitext(base)
                # support both event_2025-... and event_<num>
                idx = None
                try:
                    idx = int(name.split('_')[-1])
                except Exception:
                    idx = None
                with open(event_file, 'r') as f:
                    data = json.load(f)
                events_by_idx[idx] = data if idx is not None else data
            except Exception as e:
                print(f"Error loading {event_file}: {e}")
        return events_by_idx
    
    record_events = _load_indexed_events(record_event_files)
    replay_events = _load_indexed_events(replay_event_files)
    
    # Determine output directory structure
    if out_dir is None:
        # Use original behavior - save in output_dir
        final_output_dir = output_dir
        images_dir = None
        copy_images = False
    else:
        # Create new output structure
        final_output_dir = out_dir
        images_dir = os.path.join(out_dir, "tmp")
        copy_images = True
        
        # Create output directories
        os.makedirs(final_output_dir, exist_ok=True)
        os.makedirs(images_dir, exist_ok=True)
    
    # Generate HTML with updated image paths
    html_content = generate_html_content(record_events, replay_events, 
                                       record_states_dir, replay_states_dir, 
                                       is_replay_comparison, copy_images, images_dir)
    
    # Save HTML file
    output_file = os.path.join(final_output_dir, "action_comparison_report.html")
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    # Copy images if needed
    if copy_images:
        copy_report_images(record_states_dir, replay_states_dir, images_dir)
    
    print(f"HTML report generated: {output_file}")
    if copy_images:
        print(f"Images copied to: {images_dir}")
    return output_file


def generate_html_content(record_events, replay_events, record_states_dir, replay_states_dir, is_replay_comparison, copy_images=False, images_dir=None):
    """Generate the HTML content for the comparison report"""
    
    # Get all event indices to ensure row numbers are synchronized between columns
    record_indices = set([k for k in record_events.keys() if isinstance(k, int) and k >= 2])
    replay_indices = set([k for k in replay_events.keys() if isinstance(k, int) and k >= 2])
    all_indices = sorted(record_indices | replay_indices)
    
    html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DroidBot Action Comparison Report</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .header {{
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }}
        .comparison-container {{
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }}
        .column {{
            flex: 1;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        .column-header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
        }}
        .action-item {{
            border-bottom: 1px solid #eee;
            padding: 15px;
            transition: background-color 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }}
        .action-item:hover {{
            background-color: #f8f9fa;
        }}
        .action-item:last-child {{
            border-bottom: none;
        }}
        .action-number {{
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            font-size: 14px;
        }}
        .action-type {{
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }}
        .action-details {{
            margin-left: 40px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }}
        .detail-row {{
            margin: 5px 0;
            font-size: 14px;
        }}
        .detail-label {{
            font-weight: 600;
            color: #666;
            display: inline-block;
            width: 120px;
        }}
        .detail-value {{
            color: #333;
            word-break: break-all;
        }}
        .no-data {{
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 40px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
        }}
        .screenshot {{
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            height: 800px;
            width: 100%;
            object-fit: contain;
        }}
        .no-screenshot {{
            background-color: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            height: 796px;
            display: flex;
            align-items: center;
            justify-content: center;
        }}
        .event-type-touch {{ color: #28a745; }}
        .event-type-long_touch {{ color: #fd7e14; }}
        .event-type-scroll {{ color: #17a2b8; }}
        .event-type-intent {{ color: #6f42c1; }}
        .event-type-kill_app {{ color: #dc3545; }}
        .event-type-set_text {{ color: #20c997; }}
        .event-type-key {{ color: #e83e8c; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>DroidBot Action Comparison Report</h1>
        <p>{'Record vs Replay Comparison' if is_replay_comparison else 'Action Record Report'}</p>
        <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="comparison-container">
        <div class="column">
            <div class="column-header">
                {'Record Actions' if is_replay_comparison else 'Actions'}
            </div>
            <div class="column-content">
                {generate_synchronized_actions_html(record_events, record_states_dir, 'record', all_indices, copy_images, images_dir)}
            </div>
        </div>
        
        {f'''
        <div class="column">
            <div class="column-header">
                Replay Actions
            </div>
            <div class="column-content">
                {generate_synchronized_actions_html(replay_events, replay_states_dir, 'replay', all_indices, copy_images, images_dir)}
            </div>
        </div>
        ''' if is_replay_comparison else ''}
    </div>
</body>
</html>
"""
    return html


def create_annotated_screenshot(screenshot_path, view_data, dest_dir=None, suffix=None):
    """
    Draw a bounding rectangle annotation on the screenshot
    """
    try:
        from PIL import Image, ImageDraw
        import os
        
        # Target output directory (if provided), otherwise fall back to original behavior (write to annotation_screenshots under original directory)
        if dest_dir is not None:
            os.makedirs(dest_dir, exist_ok=True)
        
        base_name = os.path.basename(screenshot_path)
        name, ext = os.path.splitext(base_name)
        
        # If no view_data or bounds, skip annotation and only copy to target directory (if specified)
        if not view_data or 'bounds' not in view_data or not view_data['bounds'] or len(view_data['bounds']) != 2:
            if dest_dir is None:
                return screenshot_path
            # Copy original image to target directory, appending suffix if needed to avoid conflicts
            filename = f"{name}{suffix}{ext}" if suffix else base_name
            target_path = os.path.join(dest_dir, filename)
            try:
                # Using PIL to save avoids permission/timestamp issues on some platforms
                Image.open(screenshot_path).save(target_path)
            except Exception:
                import shutil
                shutil.copy2(screenshot_path, target_path)
            return target_path
        
        # Parse bounds coordinates
        (x1, y1), (x2, y2) = view_data['bounds']
        
        # Open the original image
        img = Image.open(screenshot_path)
        draw = ImageDraw.Draw(img)
        
        # Draw rectangle
        draw.rectangle([x1, y1, x2, y2], outline='red', width=3)
        
        # Generate output path
        annotated_name = f"{name}_annotated{ext}"
        if suffix:
            annotated_name = f"{name}_annotated{suffix}{ext}"
        
        if dest_dir is None:
            # Old behavior: write to annotation_screenshots under the original states directory
            os.makedirs(f"{os.path.dirname(screenshot_path)}/annotation_screenshots/", exist_ok=True)
            annotated_path = os.path.join(f"{os.path.dirname(screenshot_path)}/annotation_screenshots/", annotated_name)
        else:
            # New behavior: write directly to report output directory (without polluting original data)
            annotated_path = os.path.join(dest_dir, annotated_name)
        
        img.save(annotated_path)
        return annotated_path
        
    except Exception as e:
        print(f"Error creating annotated screenshot: {e}")
        return screenshot_path


def generate_synchronized_actions_html(events, states_dir, prefix, all_indices, copy_images=False, images_dir=None):
    """Generate HTML for synchronized actions with consistent row numbers"""
    import os
    import glob
    
    if not events:
        return '<div class="no-data">No actions recorded</div>'
    
    # Read screenshots and parse indices: screen_<idx>.png/jpg
    screenshot_index_to_path = {}
    if states_dir and os.path.exists(states_dir):
        pngs = sorted(glob.glob(os.path.join(states_dir, "screen_*.png")))
        jpgs = sorted(glob.glob(os.path.join(states_dir, "screen_*.jpg")))
        for p in pngs + jpgs:
            base = os.path.basename(p)
            name, _ = os.path.splitext(base)
            try:
                idx = int(name.split('_')[-1])
                screenshot_index_to_path[idx] = p
            except Exception:
                continue

    html_parts = []

    # Generate by unified indices to ensure row numbers are synchronized
    for event_idx in all_indices:
        # Get event data (by index)
        event = events.get(event_idx)
        action_number = event_idx - 1

        if event is not None:
            event_data = event.get('event', {})
            event_type = event_data.get('event_type', 'unknown')
            # Safely get view field; some events may not have a view
            view_data = event_data.get('view', {}) if 'view' in event_data else {}
        else:
            # Placeholder: no corresponding event
            event_data = {}
            event_type = 'missing'
            view_data = {}

        # Align screenshots: screen_idx = event_idx - 1
        screenshot_html = ""
        screen_idx = event_idx - 1
        screenshot_file = screenshot_index_to_path.get(screen_idx)
        if screenshot_file is not None:
            annotated_screenshot = create_annotated_screenshot(
                screenshot_file,
                view_data,
                images_dir if (copy_images and images_dir) else None,
                suffix='_replay' if prefix == 'replay' else None
            )
            if copy_images and images_dir:
                filename = os.path.basename(annotated_screenshot)
                relative_path = f"tmp/{filename}"
                screenshot_html = f'<img src="{relative_path}" class="screenshot" alt="Screenshot">'
            else:
                screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'
        else:
            screenshot_html = '<div class="no-screenshot">No screenshot available</div>'

        # Extract view information (safe access to avoid KeyError)
        text = view_data.get('text', '') if view_data else 'N/A'
        resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
        content_desc = view_data.get('content_description', '') if view_data else 'N/A'
        class_name = view_data.get('class', '') if view_data else 'N/A'

        # Format bounds (safe access)
        bounds_str = 'N/A'
        if view_data:
            bounds = view_data.get('bounds', [])
            if bounds and len(bounds) == 2:
                x1, y1 = bounds[0]
                x2, y2 = bounds[1]
                bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'

        # If this is a placeholder, show special content
        if event is None:
            event_type_display = 'MISSING'
            details_content = '<div class="no-data">No corresponding event</div>'
        else:
            event_type_display = event_type.upper()
            details_content = f"""
                <div class="detail-row">
                    <span class="detail-label">Text:</span>
                    <span class="detail-value">{escape_html(text)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Resource ID:</span>
                    <span class="detail-value">{escape_html(resource_id)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Content Desc:</span>
                    <span class="detail-value">{escape_html(content_desc)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Class Name:</span>
                    <span class="detail-value">{escape_html(class_name)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Bounds:</span>
                    <span class="detail-value">{bounds_str}</span>
                </div>
            """
        
        html_parts.append(f"""
        <div class="action-item">
            <div class="action-type">
                <span class="action-number">{action_number}</span>
                <span class="event-type-{event_type}">{event_type_display}</span>
            </div>
            <div class="action-details">
                {details_content}
                {screenshot_html}
            </div>
        </div>
        """)
    
    return ''.join(html_parts)


def generate_actions_html(events, states_dir, prefix, copy_images=False, images_dir=None):
    """Generate HTML for a list of actions"""
    import os
    import glob
    
    if not events:
        return '<div class="no-data">No actions recorded</div>'
    
    # Read screenshots and parse indices: screen_<idx>.png/jpg
    screenshot_index_to_path = {}
    if states_dir and os.path.exists(states_dir):
        pngs = sorted(glob.glob(os.path.join(states_dir, "screen_*.png")))
        jpgs = sorted(glob.glob(os.path.join(states_dir, "screen_*.jpg")))
        for p in pngs + jpgs:
            base = os.path.basename(p)
            name, _ = os.path.splitext(base)
            try:
                idx = int(name.split('_')[-1])
                screenshot_index_to_path[idx] = p
            except Exception:
                continue

    html_parts = []

    # Align event indices with screenshot indices: skip event 1, start from event 2, event N corresponds to screen N-1
    event_indices = sorted([k for k in events.keys() if isinstance(k, int)])
    aligned_event_indices = [i for i in event_indices if i >= 2]
    
    for event_idx in aligned_event_indices:
        # Get event data (by index)
        event = events.get(event_idx)
        action_number = event_idx - 1
        event_data = event.get('event', {}) if event is not None else {}
        event_type = event_data.get('event_type', 'unknown')
        
        # Safely get view field; some events may not have a view
        view_data = event_data.get('view', {}) if 'view' in event_data else {}

        # Align screenshots: screen_idx = event_idx - 1
        screenshot_html = ""
        screen_idx = event_idx - 1
        screenshot_file = screenshot_index_to_path.get(screen_idx)
        if screenshot_file is not None:
            annotated_screenshot = create_annotated_screenshot(
                screenshot_file,
                view_data,
                images_dir if (copy_images and images_dir) else None,
                suffix='_replay' if prefix == 'replay' else None
            )
            if copy_images and images_dir:
                filename = os.path.basename(annotated_screenshot)
                relative_path = f"tmp/{filename}"
                screenshot_html = f'<img src="{relative_path}" class="screenshot" alt="Screenshot">'
            else:
                screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'
        else:
            screenshot_html = '<div class="no-screenshot">No screenshot available</div>'
        
        # Extract view information (safe access to avoid KeyError)
        text = view_data.get('text', '') if view_data else 'N/A'
        resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
        content_desc = view_data.get('content_description', '') if view_data else 'N/A'
        class_name = view_data.get('class', '') if view_data else 'N/A'

        # Format bounds (safe access)
        bounds_str = 'N/A'
        if view_data:
            bounds = view_data.get('bounds', [])
            if bounds and len(bounds) == 2:
                x1, y1 = bounds[0]
                x2, y2 = bounds[1]
                bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'
        
        html_parts.append(f"""
        <div class="action-item">
            <div class="action-type">
                <span class="action-number">{action_number}</span>
                <span class="event-type-{event_type}">{event_type.upper()}</span>
            </div>
            <div class="action-details">
                <div class="detail-row">
                    <span class="detail-label">Text:</span>
                    <span class="detail-value">{escape_html(text)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Resource ID:</span>
                    <span class="detail-value">{escape_html(resource_id)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Content Desc:</span>
                    <span class="detail-value">{escape_html(content_desc)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Class Name:</span>
                    <span class="detail-value">{escape_html(class_name)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Bounds:</span>
                    <span class="detail-value">{bounds_str}</span>
                </div>
                {screenshot_html}
            </div>
        </div>
        """)
    
    return ''.join(html_parts)


def copy_report_images(record_states_dir, replay_states_dir, images_dir, all_indices=None):
    """Copy images used in the report to the images directory (only needed ones)

    Args:
        record_states_dir: record states directory
        replay_states_dir: replay states directory
        images_dir: output images directory
        all_indices: list of event indices to display; if None, copy all
    """
    import os
    import shutil

    if not images_dir:
        return

    def should_copy(filename, indices):
        """Check if the file needs to be copied"""
        if indices is None:
            return True
        # Filename format: screen_{idx}.png, screen_{idx}_annotated.png
        # idx = event_index - 1
        try:
            # Extract the number from the filename
            name = os.path.splitext(filename)[0]
            # Handle _annotated suffix
            if '_annotated' in name:
                name = name.replace('_annotated', '')
            if '_replay' in name:
                name = name.replace('_replay', '')
            # Extract the number after screen_
            if name.startswith('screen_'):
                idx = int(name.split('_')[1])
                # screen_idx corresponds to event_idx+1
                event_idx = idx + 1
                return event_idx in indices
        except (ValueError, IndexError):
            pass
        return False

    # Copy record images
    if record_states_dir and os.path.exists(record_states_dir):
        # Copy original screenshots (only needed ones)
        for ext in ['png', 'jpg']:
            for f in os.listdir(record_states_dir):
                if f.startswith('screen_') and f.endswith(f'.{ext}'):
                    if should_copy(f, all_indices):
                        src = os.path.join(record_states_dir, f)
                        dst = os.path.join(images_dir, f)
                        shutil.copy2(src, dst)

        # Copy annotated screenshots (only needed ones)
        annotation_dir = os.path.join(record_states_dir, "annotation_screenshots")
        if os.path.exists(annotation_dir):
            for f in os.listdir(annotation_dir):
                if '_annotated' in f:
                    if should_copy(f, all_indices):
                        src = os.path.join(annotation_dir, f)
                        dst = os.path.join(images_dir, f)
                        shutil.copy2(src, dst)

    # Copy replay images
    if replay_states_dir and os.path.exists(replay_states_dir):
        # Copy original screenshots (only needed ones)
        for ext in ['png', 'jpg']:
            for f in os.listdir(replay_states_dir):
                if f.startswith('screen_') and f.endswith(f'.{ext}'):
                    if should_copy(f, all_indices):
                        src = os.path.join(replay_states_dir, f)
                        # Add replay prefix to avoid conflicts
                        name, ext_part = os.path.splitext(f)
                        replay_filename = f"{name}_replay{ext_part}"
                        dst = os.path.join(images_dir, replay_filename)
                        shutil.copy2(src, dst)

        # Copy annotated screenshots (only needed ones)
        annotation_dir = os.path.join(replay_states_dir, "annotation_screenshots")
        if os.path.exists(annotation_dir):
            for f in os.listdir(annotation_dir):
                if '_annotated' in f:
                    if should_copy(f, all_indices):
                        src = os.path.join(annotation_dir, f)
                        # Add replay prefix to avoid conflicts
                        name, ext_part = os.path.splitext(f)
                        replay_filename = f"{name}_replay{ext_part}"
                        dst = os.path.join(images_dir, replay_filename)
                        shutil.copy2(src, dst)


def escape_html(text):
    """Escape HTML special characters"""
    if not text:
        return 'N/A'
    return (str(text)
            .replace('&', '&amp;')
            .replace('<', '&lt;')
            .replace('>', '&gt;')
            .replace('"', '&quot;')
            .replace("'", '&#x27;'))

def get_repair_trace_info(repair_dir, failed_event_number):
    """
    Read repair trace JSON file

    Args:
        repair_dir: path to repair output directory
        failed_event_number: the failed event number

    Returns:
        repair trace info dictionary, or None if the file does not exist
    """
    import os
    import json
    import glob

    # Build the repair_trace file path
    repair_trace_path = os.path.join(
        repair_dir,
        "exploration_tmp",
        "repair_logs",
        f"repair_trace_event_{failed_event_number}.json"
    )

    print(f"[DEBUG] Looking for repair trace at: {repair_trace_path}")

    if not os.path.exists(repair_trace_path):
        # Try to find any existing repair_trace files
        repair_logs_dir = os.path.join(repair_dir, "exploration_tmp", "repair_logs")
        if os.path.exists(repair_logs_dir):
            trace_files = glob.glob(os.path.join(repair_logs_dir, "repair_trace_event_*.json"))
            print(f"[DEBUG] Found trace files in {repair_logs_dir}: {trace_files}")
            if trace_files:
                # Use the first available trace file
                repair_trace_path = trace_files[0]
                print(f"[DEBUG] Using first available trace file: {repair_trace_path}")
            else:
                print(f"[DEBUG] No trace files found in {repair_logs_dir}")
                return None
        else:
            print(f"[DEBUG] repair_logs dir not found: {repair_logs_dir}")
            return None

    try:
        with open(repair_trace_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            print(f"[DEBUG] Loaded trace with {len(data.get('trace', []))} steps")
            return data
    except Exception as e:
        print(f"Failed to read repair trace: {e}")
        return None


def generate_repair_step_html(repair_dir, failed_event_number, step_data, images_dir=None):
    """
    Generate HTML content for a single repair step

    Args:
        repair_dir: repair output directory
        failed_event_number: the failed event number
        step_data: data for a single step
        images_dir: image output directory

    Returns:
        HTML string
    """
    from PIL import Image, ImageDraw, ImageFont

    step_num = step_data.get('step', 0)
    action = step_data.get('action', 'unknown')
    repair_success = step_data.get('_repair_success', False)

    # Get view-related information
    bounds = None
    text = None
    resource_id = None
    content_desc = None
    class_name = None
    direction = None  # For scroll-type actions
    event_type = None  # For navigation actions

    if action == 'navigation':
        event = step_data.get('event', {})
        if event:
            event_type = event.get('type', 'touch')
            if 'view' in event and event['view']:
                bounds = event['view'].get('bounds')
                text = event['view'].get('text')
                resource_id = event['view'].get('resource_id')
                content_desc = event['view'].get('content_description')
                class_name = event['view'].get('class')
    elif action == 'match_found':
        matched_view = step_data.get('matched_view', {})
        if matched_view:
            bounds = matched_view.get('bounds')
            text = matched_view.get('text')
            resource_id = matched_view.get('resource_id')
            content_desc = matched_view.get('content_description')
            class_name = matched_view.get('class')
    elif action in ['scroll', 'reverse_scroll']:
        direction = step_data.get('direction', 'unknown')
        event = step_data.get('event', {})
        if event and 'view' in event and event['view']:
            bounds = event['view'].get('bounds')
    elif action == 'back':
        pass  # back has no additional information
    elif action == 'scroll_down':
        direction = 'down'

    # Build the full screenshot path
    # Choose different screenshot paths based on action type
    if action == 'match_found':
        # match_found uses marked_matched_view_step_*.png, pick the one with the largest index
        import glob
        source_images_dir = os.path.join(repair_dir, "exploration_tmp", "images")
        matched_files = glob.glob(os.path.join(source_images_dir, "marked_matched_view_step_*.png"))
        if matched_files:
            # Extract indices and find the largest
            max_num = -1
            full_screenshot_path = None
            for f in matched_files:
                try:
                    # Filename format: marked_matched_view_step_X.png
                    basename = os.path.basename(f)
                    num = int(basename.replace("marked_matched_view_step_", "").replace(".png", ""))
                    if num > max_num:
                        max_num = num
                        full_screenshot_path = f
                except:
                    continue
            if full_screenshot_path is None:
                full_screenshot_path = matched_files[0]  # fallback
        else:
            full_screenshot_path = os.path.join(source_images_dir, f"marked_matched_view_step_{step_num}.png")
    else:
        # Other actions use screen_same_page_{step_num}.png
        full_screenshot_path = os.path.join(repair_dir, "exploration_tmp", "states", f"screen_same_page_{step_num}.png")

    print(f"[DEBUG] Step {step_num} ({action}): trying path {full_screenshot_path}, exists={os.path.exists(full_screenshot_path)}")

    # If the default path does not exist, try using the path recorded in the trace
    if not os.path.exists(full_screenshot_path):
        trace_screenshot = step_data.get('screenshot')
        if trace_screenshot:
            # If it's an absolute path use it directly, otherwise try relative to repair_dir's parent directory
            if os.path.isabs(trace_screenshot):
                full_screenshot_path = trace_screenshot
            else:
                # Try to find from repair_dir's parent directory
                parent_dir = os.path.dirname(os.path.dirname(repair_dir))
                full_screenshot_path = os.path.join(parent_dir, trace_screenshot)
            print(f"[DEBUG] Step {step_num}: fallback path {full_screenshot_path}, exists={os.path.exists(full_screenshot_path)}")

    # Determine if there is a screenshot (back and scroll_down do not have one)
    has_screenshot = action not in ['back', 'scroll_down']

    # Generate screenshot HTML
    screenshot_html = '<div class="no-screenshot">No screenshot</div>'
    if has_screenshot and full_screenshot_path and os.path.exists(full_screenshot_path):
        try:
            # match_found images are already annotated, just copy without redrawing
            if action == 'match_found':
                if images_dir:
                    import shutil
                    os.makedirs(images_dir, exist_ok=True)
                    output_filename = f"repair_step_{failed_event_number}_{step_num}.png"
                    output_path = os.path.join(images_dir, output_filename)
                    shutil.copy2(full_screenshot_path, output_path)
                    screenshot_html = f'<img src="tmp/{output_filename}" class="screenshot" alt="Repair Step {step_num}">'
                else:
                    screenshot_html = f'<img src="{full_screenshot_path}" class="screenshot" alt="Repair Step {step_num}">'
            else:
                # Other action types need PIL to draw annotations
                img = Image.open(full_screenshot_path)
                if img.mode != 'RGBA':
                    img = img.convert('RGBA')

                draw = ImageDraw.Draw(img)
                try:
                    font = ImageFont.truetype("/System/Library/Fonts/Arial.ttf", 24)
                except:
                    font = ImageFont.load_default()

                # Draw different annotations based on action type
                if action == 'navigation':
                    color = (0, 100, 200)  # Blue
                    label = f"Step {step_num}"
                elif action in ['scroll', 'reverse_scroll']:
                    color = (255, 165, 0)  # Orange
                    label = f"Step {step_num} ({direction})"
                else:
                    color = (128, 128, 128)  # Gray
                    label = f"Step {step_num}"

                # If bounds are available, draw a bounding rectangle
                if bounds and len(bounds) == 2:
                    x1, y1 = bounds[0]
                    x2, y2 = bounds[1]
                    draw.rectangle([x1, y1, x2, y2], outline=color, width=4)

                    bbox = draw.textbbox((0, 0), label, font=font)
                    text_w = bbox[2] - bbox[0]
                    text_h = bbox[3] - bbox[1]
                    text_x = x1 + ((x2 - x1) - text_w) // 2
                    text_y = max(0, y1 - text_h - 8)

                    draw.rectangle([text_x - 4, text_y - 4, text_x + text_w + 4, text_y + text_h + 4], fill=color)
                    draw.text((text_x, text_y), label, fill="white", font=font)
                elif action in ['scroll', 'reverse_scroll']:
                    # For scroll actions, display direction arrow at the center of the screen
                    img_w, img_h = img.size
                    center_x, center_y = img_w // 2, img_h // 2

                    # Draw direction label
                    bbox = draw.textbbox((0, 0), label, font=font)
                    text_w = bbox[2] - bbox[0]
                    text_h = bbox[3] - bbox[1]
                    text_x = center_x - text_w // 2
                    text_y = center_y - text_h // 2

                    draw.rectangle([text_x - 8, text_y - 8, text_x + text_w + 8, text_y + text_h + 8], fill=color)
                    draw.text((text_x, text_y), label, fill="white", font=font)

                if images_dir:
                    os.makedirs(images_dir, exist_ok=True)
                    output_filename = f"repair_step_{failed_event_number}_{step_num}.png"
                    output_path = os.path.join(images_dir, output_filename)
                    img.save(output_path)
                    screenshot_html = f'<img src="tmp/{output_filename}" class="screenshot" alt="Repair Step {step_num}">'
                else:
                    screenshot_html = f'<img src="{full_screenshot_path}" class="screenshot" alt="Repair Step {step_num}">'

        except Exception as e:
            print(f"Error processing repair screenshot: {e}")
            screenshot_html = '<div class="no-screenshot">Error loading screenshot</div>'
    elif not has_screenshot:
        # back and scroll_down have no screenshots, show action info instead
        screenshot_html = f'<div class="no-screenshot" style="font-size: 24px;">ðŸ“± {action.upper()}</div>'

    # Set action display name and color
    action_display_map = {
        'navigation': ('Navigation', '#007bff'),
        'match_found': ('Target Found', '#28a745'),
        'scroll': ('Scroll', '#fd7e14'),
        'reverse_scroll': ('Reverse Scroll', '#e83e8c'),
        'back': ('Back', '#6c757d'),
        'scroll_down': ('Scroll Down', '#17a2b8'),
    }
    action_display, action_color = action_display_map.get(action, (action.title(), '#6c757d'))

    # Format display values
    text_display = text if text else "N/A"
    resource_id_display = resource_id if resource_id else "N/A"
    content_desc_display = content_desc if content_desc else "N/A"
    class_name_display = class_name if class_name else "N/A"

    # Format bounds display
    if bounds and len(bounds) == 2:
        bounds_display = f"({bounds[0][0]}, {bounds[0][1]}) - ({bounds[1][0]}, {bounds[1][1]})"
    else:
        bounds_display = "N/A"

    # Extra information (direction, event_type)
    extra_info_html = ""
    if direction:
        extra_info_html += f"""
            <div class="detail-row">
                <span class="detail-label">Direction:</span>
                <span class="detail-value">{direction}</span>
            </div>
        """
    if event_type:
        extra_info_html += f"""
            <div class="detail-row">
                <span class="detail-label">Event Type:</span>
                <span class="detail-value">{event_type}</span>
            </div>
        """

    return f"""
    <div class="action-item">
        <div class="action-type">
            <span class="action-number">{step_num}</span>
            <span style="color: {action_color};">{action_display}</span>
        </div>
        <div class="action-details">
            {extra_info_html}
            <div class="detail-row">
                <span class="detail-label">Text:</span>
                <span class="detail-value">{text_display}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Resource ID:</span>
                <span class="detail-value">{resource_id_display}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Content Desc:</span>
                <span class="detail-value">{content_desc_display}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Class Name:</span>
                <span class="detail-value">{class_name_display}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Bounds:</span>
                <span class="detail-value">{bounds_display}</span>
            </div>
            {screenshot_html}
        </div>
    </div>
    """


def generate_synchronized_repair_html(repair_dir, failed_event_number, all_indices, images_dir=None):
    """
    Generate repair column HTML aligned with record/replay

    Display logic for the repair column:
    - event < failed_event: load normal events from repair_dir/events/
    - event == failed_event: show all repair trace steps from exploration_tmp
    - event > failed_event: continue loading normal events from repair_dir/events/

    Args:
        repair_dir: repair output directory
        failed_event_number: the failed event number
        all_indices: list of all event indices
        images_dir: image output directory

    Returns:
        HTML string
    """
    import json
    import glob

    # Load repair trace
    trace_info = get_repair_trace_info(repair_dir, failed_event_number)
    repair_success = trace_info.get('repair_success', False) if trace_info else False
    trace = trace_info.get('trace', []) if trace_info else []

    # Load normal events from repair_dir/events/
    repair_events = {}
    repair_events_dir = os.path.join(repair_dir, "events")
    if os.path.exists(repair_events_dir):
        event_paths = glob.glob(os.path.join(repair_events_dir, "event_*.json"))
        for event_file in event_paths:
            try:
                base = os.path.basename(event_file)
                name, _ = os.path.splitext(base)
                idx = int(name.split('_')[-1])
                with open(event_file, 'r') as f:
                    repair_events[idx] = json.load(f)
            except Exception as e:
                print(f"Error loading repair event {event_file}: {e}")

    # Load repair screenshot mapping
    repair_states_dir = os.path.join(repair_dir, "states")
    repair_screenshot_map = {}
    if os.path.exists(repair_states_dir):
        pngs = glob.glob(os.path.join(repair_states_dir, "screen_*.png"))
        jpgs = glob.glob(os.path.join(repair_states_dir, "screen_*.jpg"))
        for p in pngs + jpgs:
            base = os.path.basename(p)
            name, _ = os.path.splitext(base)
            try:
                idx = int(name.split('_')[-1])
                repair_screenshot_map[idx] = p
            except:
                continue

    html_parts = []

    for event_idx in all_indices:
        if event_idx == failed_event_number:
            # Failed event, show all repair trace steps
            if trace:
                for step_data in trace:
                    step_data['_repair_success'] = repair_success
                    html_parts.append(generate_repair_step_html(repair_dir, failed_event_number, step_data, images_dir))
            else:
                html_parts.append(f"""
                <div class="action-item">
                    <div class="action-type">
                        <span class="action-number">{event_idx - 1}</span>
                        <span style="color: #dc3545;">REPAIR</span>
                    </div>
                    <div class="action-details">
                        <div class="no-screenshot">No repair data for event {failed_event_number}</div>
                    </div>
                </div>
                """)
        else:
            # Non-failed event, load normal event from repair_dir/events/ for display
            action_number = event_idx - 1
            repair_event = repair_events.get(event_idx)

            if repair_event:
                event_data = repair_event.get('event', {})
                event_type = event_data.get('event_type', 'unknown')
                view_data = event_data.get('view', {}) if 'view' in event_data else {}

                # Get screenshot (screen_idx = event_idx - 1)
                screen_idx = event_idx - 1
                screenshot_file = repair_screenshot_map.get(screen_idx)
                screenshot_html = '<div class="no-screenshot">No screenshot</div>'

                if screenshot_file and os.path.exists(screenshot_file):
                    annotated_screenshot = create_annotated_screenshot(
                        screenshot_file,
                        view_data,
                        images_dir,
                        suffix='_repair'
                    )
                    if images_dir:
                        filename = os.path.basename(annotated_screenshot)
                        screenshot_html = f'<img src="tmp/{filename}" class="screenshot" alt="Screenshot">'
                    else:
                        screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'

                # Extract view information
                text = view_data.get('text', '') if view_data else 'N/A'
                resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
                content_desc = view_data.get('content_description', '') if view_data else 'N/A'
                class_name = view_data.get('class', '') if view_data else 'N/A'

                bounds_str = 'N/A'
                if view_data:
                    bounds = view_data.get('bounds', [])
                    if bounds and len(bounds) == 2:
                        x1, y1 = bounds[0]
                        x2, y2 = bounds[1]
                        bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'

                html_parts.append(f"""
                <div class="action-item">
                    <div class="action-type">
                        <span class="action-number">{action_number}</span>
                        <span class="event-type-{event_type}">{event_type.upper()}</span>
                    </div>
                    <div class="action-details">
                        <div class="detail-row">
                            <span class="detail-label">Text:</span>
                            <span class="detail-value">{escape_html(text)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Resource ID:</span>
                            <span class="detail-value">{escape_html(resource_id)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Content Desc:</span>
                            <span class="detail-value">{escape_html(content_desc)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Class Name:</span>
                            <span class="detail-value">{escape_html(class_name)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Bounds:</span>
                            <span class="detail-value">{bounds_str}</span>
                        </div>
                        {screenshot_html}
                    </div>
                </div>
                """)
            else:
                # Repair directory does not have this event, show placeholder
                html_parts.append(f"""
                <div class="action-item">
                    <div class="action-type">
                        <span class="action-number" style="background: #ffc107;">{action_number}</span>
                        <span style="color: #856404;">MISSING</span>
                    </div>
                    <div class="action-details">
                        <div class="no-screenshot">No event {event_idx} in repair</div>
                    </div>
                </div>
                """)

    return ''.join(html_parts) if html_parts else '<div class="no-data">No repair data</div>'


def generate_actions_html_for_repair_report(events, states_dir, prefix, all_indices, failed_event_number, trace_steps_count, copy_images=False, images_dir=None):
    """
    Generate actions HTML for repair report, placing multiple placeholders at the failed_event position to align with repair trace

    Args:
        events: events dictionary
        states_dir: screenshot directory
        prefix: 'record' or 'replay'
        all_indices: all event indices
        failed_event_number: the failed event number
        trace_steps_count: number of steps in the repair trace
        copy_images: whether to copy images
        images_dir: image output directory
    """
    import glob

    if not events:
        return '<div class="no-data">No actions recorded</div>'

    # Read screenshot mapping
    screenshot_index_to_path = {}
    if states_dir and os.path.exists(states_dir):
        pngs = sorted(glob.glob(os.path.join(states_dir, "screen_*.png")))
        jpgs = sorted(glob.glob(os.path.join(states_dir, "screen_*.jpg")))
        for p in pngs + jpgs:
            base = os.path.basename(p)
            name, _ = os.path.splitext(base)
            try:
                idx = int(name.split('_')[-1])
                screenshot_index_to_path[idx] = p
            except:
                continue

    html_parts = []

    for event_idx in all_indices:
        action_number = event_idx - 1

        if event_idx == failed_event_number:
            # At the failed_event position, first show the original event (if available)
            event = events.get(event_idx)
            screen_idx = event_idx - 1
            screenshot_file = screenshot_index_to_path.get(screen_idx)

            if event is not None or screenshot_file is not None:
                # Has event or screenshot, show original content first
                if event is not None:
                    event_data = event.get('event', {})
                    event_type = event_data.get('event_type', 'unknown')
                    view_data = event_data.get('view', {}) if 'view' in event_data else {}
                else:
                    event_data = {}
                    event_type = 'missing'
                    view_data = {}

                screenshot_html = '<div class="no-screenshot">No screenshot available</div>'
                if screenshot_file is not None:
                    annotated_screenshot = create_annotated_screenshot(
                        screenshot_file,
                        view_data,
                        images_dir if (copy_images and images_dir) else None,
                        suffix=f'_{prefix}' if prefix == 'replay' else None
                    )
                    if copy_images and images_dir:
                        filename = os.path.basename(annotated_screenshot)
                        screenshot_html = f'<img src="tmp/{filename}" class="screenshot" alt="Screenshot">'
                    else:
                        screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'

                # Extract view information
                text = view_data.get('text', '') if view_data else 'N/A'
                resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
                content_desc = view_data.get('content_description', '') if view_data else 'N/A'
                class_name = view_data.get('class', '') if view_data else 'N/A'
                bounds_str = 'N/A'
                if view_data:
                    bounds = view_data.get('bounds', [])
                    if bounds and len(bounds) == 2:
                        x1, y1 = bounds[0]
                        x2, y2 = bounds[1]
                        bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'

                if event is None:
                    event_type_display = 'MISSING'
                    details_content = ''
                else:
                    event_type_display = event_type.upper()
                    details_content = f"""
                        <div class="detail-row">
                            <span class="detail-label">Text:</span>
                            <span class="detail-value">{escape_html(text)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Resource ID:</span>
                            <span class="detail-value">{escape_html(resource_id)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Content Desc:</span>
                            <span class="detail-value">{escape_html(content_desc)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Class Name:</span>
                            <span class="detail-value">{escape_html(class_name)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Bounds:</span>
                            <span class="detail-value">{bounds_str}</span>
                        </div>
                    """

                html_parts.append(f"""
                <div class="action-item">
                    <div class="action-type">
                        <span class="action-number">{action_number}</span>
                        <span class="event-type-{event_type}">{event_type_display}</span>
                    </div>
                    <div class="action-details">
                        {details_content}
                        {screenshot_html}
                    </div>
                </div>
                """)

                # Add trace_steps_count - 1 placeholders
                for step_i in range(1, trace_steps_count):
                    html_parts.append(f"""
                    <div class="action-item">
                        <div class="action-type">
                            <span class="action-number" style="background: #6c757d;">{action_number}</span>
                            <span style="color: #6c757d;">REPAIR STEP {step_i}</span>
                        </div>
                        <div class="action-details">
                            <div class="no-screenshot">See Repair column</div>
                        </div>
                    </div>
                    """)
            else:
                # No event and no screenshot, use placeholders for all
                for step_i in range(trace_steps_count):
                    html_parts.append(f"""
                    <div class="action-item">
                        <div class="action-type">
                            <span class="action-number" style="background: #6c757d;">{action_number}</span>
                            <span style="color: #6c757d;">REPAIR STEP {step_i}</span>
                        </div>
                        <div class="action-details">
                            <div class="no-screenshot">See Repair column</div>
                        </div>
                    </div>
                    """)
        else:
            # Display event normally
            event = events.get(event_idx)

            if event is not None:
                event_data = event.get('event', {})
                event_type = event_data.get('event_type', 'unknown')
                view_data = event_data.get('view', {}) if 'view' in event_data else {}
            else:
                event_data = {}
                event_type = 'missing'
                view_data = {}

            # Get screenshot
            screen_idx = event_idx - 1
            screenshot_file = screenshot_index_to_path.get(screen_idx)
            screenshot_html = '<div class="no-screenshot">No screenshot available</div>'

            if screenshot_file is not None:
                annotated_screenshot = create_annotated_screenshot(
                    screenshot_file,
                    view_data,
                    images_dir if (copy_images and images_dir) else None,
                    suffix=f'_{prefix}' if prefix == 'replay' else None
                )
                if copy_images and images_dir:
                    filename = os.path.basename(annotated_screenshot)
                    screenshot_html = f'<img src="tmp/{filename}" class="screenshot" alt="Screenshot">'
                else:
                    screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'

            # Extract view information
            text = view_data.get('text', '') if view_data else 'N/A'
            resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
            content_desc = view_data.get('content_description', '') if view_data else 'N/A'
            class_name = view_data.get('class', '') if view_data else 'N/A'

            bounds_str = 'N/A'
            if view_data:
                bounds = view_data.get('bounds', [])
                if bounds and len(bounds) == 2:
                    x1, y1 = bounds[0]
                    x2, y2 = bounds[1]
                    bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'

            if event is None:
                event_type_display = 'MISSING'
                # If there is a screenshot, do not show the "No corresponding event" message
                if screenshot_file is not None:
                    details_content = ''
                else:
                    details_content = '<div class="no-data">No corresponding event</div>'
            else:
                event_type_display = event_type.upper()
                details_content = f"""
                    <div class="detail-row">
                        <span class="detail-label">Text:</span>
                        <span class="detail-value">{escape_html(text)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Resource ID:</span>
                        <span class="detail-value">{escape_html(resource_id)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Content Desc:</span>
                        <span class="detail-value">{escape_html(content_desc)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Class Name:</span>
                        <span class="detail-value">{escape_html(class_name)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Bounds:</span>
                        <span class="detail-value">{bounds_str}</span>
                    </div>
                """

            html_parts.append(f"""
            <div class="action-item">
                <div class="action-type">
                    <span class="action-number">{action_number}</span>
                    <span class="event-type-{event_type}">{event_type_display}</span>
                </div>
                <div class="action-details">
                    {details_content}
                    {screenshot_html}
                </div>
            </div>
            """)

    return ''.join(html_parts)


def generate_html_report_with_repair(record_dir, replay_dir, repair_dir, out_dir, simple=False):
    """
    Generate a three-column HTML report: Record, Replay, Repair

    Args:
        record_dir: record output directory
        replay_dir: replay output directory
        repair_dir: repair output directory
        out_dir: HTML report output directory
        simple: whether to only generate content for failed_event_number-1, failed_event_number, and failed_event_number+1
    """
    import os
    import json
    import glob
    import shutil

    # Create output directories
    os.makedirs(out_dir, exist_ok=True)
    images_dir = os.path.join(out_dir, "tmp")
    os.makedirs(images_dir, exist_ok=True)

    # Get failed_event_number (max event number in replay directory + 1)
    replay_events_dir = os.path.join(replay_dir, "events")
    event_files = glob.glob(os.path.join(replay_events_dir, "event_*.json"))
    max_event = 0
    for f in event_files:
        try:
            num = int(os.path.basename(f).replace('event_', '').replace('.json', ''))
            max_event = max(max_event, num)
        except:
            continue
    failed_event_number = max_event + 1

    # Load events
    def _load_indexed_events(events_dir):
        events_by_idx = {}
        event_paths = glob.glob(os.path.join(events_dir, "event_*.json"))
        for event_file in event_paths:
            try:
                base = os.path.basename(event_file)
                name, _ = os.path.splitext(base)
                idx = int(name.split('_')[-1])
                with open(event_file, 'r') as f:
                    events_by_idx[idx] = json.load(f)
            except Exception as e:
                print(f"Error loading {event_file}: {e}")
        return events_by_idx

    record_events = _load_indexed_events(os.path.join(record_dir, "events"))
    replay_events = _load_indexed_events(os.path.join(replay_dir, "events"))

    record_states_dir = os.path.join(record_dir, "states")
    replay_states_dir = os.path.join(replay_dir, "states")

    # Get repair trace
    trace_info = get_repair_trace_info(repair_dir, failed_event_number)
    repair_success = trace_info.get('repair_success', False) if trace_info else False
    trace_steps_count = len(trace_info.get('trace', [])) if trace_info else 1

    # Get all event indices
    record_indices = set([k for k in record_events.keys() if isinstance(k, int) and k >= 2])
    replay_indices = set([k for k in replay_events.keys() if isinstance(k, int) and k >= 2])
    all_indices = sorted(record_indices | replay_indices)

    # In simple mode, only keep failed_event_number-1, failed_event_number, and failed_event_number+1
    if simple:
        simple_indices = [failed_event_number - 1, failed_event_number, failed_event_number + 1]
        all_indices = [idx for idx in all_indices if idx in simple_indices]
        print(f"[DEBUG] Simple mode: showing only events {all_indices}")

    # Generate HTML
    html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DroidBot Record/Replay/Repair Report</title>
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
        .header {{ text-align: center; margin-bottom: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; }}
        .comparison-container {{ display: flex; gap: 20px; max-width: 2100px; margin: 0 auto; }}
        .column {{ flex: 1; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; }}
        .column-header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; text-align: center; font-weight: bold; font-size: 18px; }}
        .column-header.repair {{ background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }}
        .action-item {{ border-bottom: 1px solid #eee; padding: 15px; min-height: 800px; }}
        .action-number {{ background: #007bff; color: white; border-radius: 50%; width: 30px; height: 30px; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; }}
        .action-type {{ font-weight: bold; color: #333; margin-bottom: 8px; font-size: 16px; }}
        .action-details {{ margin-left: 40px; }}
        .detail-row {{ margin: 5px 0; font-size: 14px; }}
        .detail-label {{ font-weight: 600; color: #666; display: inline-block; width: 120px; }}
        .screenshot {{ border-radius: 5px; margin-top: 10px; height: 600px; width: 100%; object-fit: contain; }}
        .no-screenshot {{ background: #f8f9fa; border: 2px dashed #dee2e6; border-radius: 5px; margin-top: 10px; text-align: center; color: #6c757d; height: 596px; display: flex; align-items: center; justify-content: center; }}
        .no-data {{ text-align: center; color: #999; font-style: italic; padding: 10px; }}
        .repair-status {{ padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center; font-weight: bold; }}
        .repair-success {{ background: #d4edda; color: #155724; }}
        .repair-failed {{ background: #f8d7da; color: #721c24; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>DroidBot Record/Replay/Repair Report</h1>
        <p>Failed Event: {failed_event_number} | Repair Status: <span style="color: {'#90EE90' if repair_success else '#FFB6C1'};">{'Success' if repair_success else 'Failed'}</span></p>
        <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>

    <div class="comparison-container">
        <div class="column">
            <div class="column-header">Record Actions</div>
            <div class="column-content">
                {generate_actions_html_for_repair_report(record_events, record_states_dir, 'record', all_indices, failed_event_number, trace_steps_count, True, images_dir)}
            </div>
        </div>

        <div class="column">
            <div class="column-header">Replay Actions</div>
            <div class="column-content">
                {generate_actions_html_for_repair_report(replay_events, replay_states_dir, 'replay', all_indices, failed_event_number, trace_steps_count, True, images_dir)}
            </div>
        </div>

        <div class="column">
            <div class="column-header repair">Repair Process</div>
            <div class="column-content">
                {generate_synchronized_repair_html(repair_dir, failed_event_number, all_indices, images_dir)}
            </div>
        </div>
    </div>
</body>
</html>
"""

    # Save HTML
    output_file = os.path.join(out_dir, "action_comparison_report.html")
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(html)

    # Copy images (only the ones needed)
    copy_report_images(record_states_dir, replay_states_dir, images_dir, all_indices)

    print(f"HTML report generated: {output_file}")
    return output_file


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate HTML report comparing record, replay, and repair data')
    parser.add_argument('-record', '--record-dir', required=True,
                        help='Directory containing record data (original test output)')
    parser.add_argument('-replay', '--replay-dir', required=True,
                        help='Directory containing replay data')
    parser.add_argument('-repair', '--repair-dir', default=None,
                        help='Directory containing repair data (optional, enables 3-column view)')
    parser.add_argument('-output', '--output-dir', default='trace_html_report',
                        help='Output directory for the HTML report')
    parser.add_argument('-simple', '--simple', action='store_true',
                        help='Generate simplified report with only failed_event_number-1, failed_event_number, and failed_event_number+1')

    args = parser.parse_args()

    if args.repair_dir and os.path.exists(args.repair_dir):
        # Three-column mode: Record + Replay + Repair
        generate_html_report_with_repair(args.record_dir, args.replay_dir, args.repair_dir, args.output_dir, args.simple)
    else:
        # Two-column mode: Record + Replay
        generate_html_report(args.record_dir, args.replay_dir, args.output_dir)
